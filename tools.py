from langchain_core.tools import tool
from pathlib import Path
from unidiff import PatchSet
import re

@tool
def read_file(filepath : str):
    """tool for reading a file\nargs: filepath\nreturn: data of the file"""
    file = Path(filepath)
    if not file.exists():
        return "No such file exists. Please check the filepath provided."
    try:
        data = file.read_text(encoding="utf-8")
        return f"File read successfully! from {filepath} \n\n{data}"
    except Exception as e:
        return f"An error occurred while reading the file: {e}"

@tool
def read_file_lines(filepath: str, start_line: int, end_line: int):
    """tool for reading specific lines from a file (1-indexed, inclusive), returning line numbers and content"""
    file = Path(filepath)
    if not file.exists():
        return "No such file exists. Please check the filepath provided."
    try:
        lines = file.read_text(encoding="utf-8").splitlines()
        if start_line < 1 or end_line > len(lines) or start_line > end_line:
            return f"Invalid line range: file has {len(lines)} lines."
        selected = lines[start_line-1:end_line]
        # Add line numbers to each line
        numbered = [
            f"Line {i+start_line}: {line}" for i, line in enumerate(selected)
        ]
        return f"Successfully read the file {filepath}>" + "\n".join(numbered)
    except Exception as e:
        return f"An error occurred while reading the file: {e}"

@tool
def write_file_lines(filepath: str, start_line: int, end_line: int, content: str):
    """tool for writing (replacing) specific lines in a file (1-indexed, inclusive) with the given content, expanding the file if needed"""
    file = Path(filepath)
    if not file.exists():
        print(filepath)
        return f"No such file exists. Please check the filepath provided. {filepath}"
    try:
        lines = file.read_text(encoding="utf-8").splitlines()
        # Pad with empty lines if needed
        if len(lines) < end_line:
            lines.extend([''] * (end_line - len(lines)))
        # Split the new content into lines
        new_lines = content.splitlines()
        # Replace the specified lines
        lines[start_line-1:end_line] = new_lines
        # Write back to the file
        file.write_text("\n".join(lines), encoding="utf-8")
        return f"Successfully wrote to lines {start_line}-{end_line} in {filepath}."
    except Exception as e:
        return f"An error occurred while writing to the file: {e}"

@tool
def find_file_in_codebase(filename: str):
    """Tool to find the relative filepath of a file in the codebase given its name. Searches recursively from the current working directory."""
    base_dir = Path(__file__).parent.parent  # Current working directory
    matches = list(base_dir.rglob(filename))
    if matches:
        rel_path = matches[0].resolve()
        return str(rel_path)    
    else:
        return f"File '{filename}' not found in the codebase."

@tool
def apply_code_replacements(file_path, replacements):
    """Hey yo, this replaces all the code generated by the llm in place"""
    content = Path(file_path).read_text()
    for change in replacements:
        # Use dict access for compatibility
        old_code = change['old_code'] if isinstance(change, dict) else change.old_code
        new_code = change['new_code'] if isinstance(change, dict) else change.new_code
        pattern = re.escape(old_code)
        content, count = re.subn(pattern, new_code, content, count=1)
        if count == 0:
            print(f"Warning: old_code not found in file:\n{old_code}")
    Path(file_path).write_text(content)
    return "Code replacements applied successfully!"

content = ""
# print(read_file_lines.invoke({"filepath": "codexp_chain.py", "start_line": 1, "end_line": 10}))

